{"id": "cvdp_copilot_lfsr_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design the RTL for an 8-bit Linear Feedback Shift Register (LFSR) by utilizing the primitive polynomial **x<sup>8</sup>+x<sup>6</sup>+x<sup>5</sup>+x+1** under Galois configuration to construct maximal length pseudo-random sequences.\n\n## Design Specification:\n\n- LFSRs configured in the Galois style operate using an internal feedback system. \n- In this arrangement, the feedback taps directly impact specific bits within the shift register.\n- A distinctive characteristic of Galois LFSRs is that only one bit is shifted per clock cycle, with the feedback bit selectively toggling the bits at the designated tap positions.\n- In this setup, the output from the final register undergoes an XOR operation with the outputs of selected register bits, which are determined by the coefficients of the primitive polynomial. For a polynomial of degree n, the positions of non-zero coefficients, excluding the nth and zeroth, are considered when performing the XOR operations.\n\n#### Structure of Galois configuration\n- Registers: A set of flip-flops connected in series, each holding a single bit\n- Feedback mechanism: Feedback is taken from the output of the last flip-flop and applied to various taps (which are bits in the register) using XOR gates\n- Shift: On each clock cycle, the bits are shifted to the right, and the feedback bit is XORed with some of the bits in the registers before shifting\n\n#### Working example\n\nLet `lfsr_out [7:0]` be the 8-bit output of LFSR. Assume `lfsr_out[7]` and `lfsr_out[0]` as MSB and LSBs of the output of 8-bit LFSR under Galois configuration with the polynomial **x<sup>8</sup>+x<sup>6</sup>+x <sup>5</sup>+x+1**\n\nExpanding the coefficients of the polynomial,\n\n**1 . x<sup>8</sup> + 0 . x<sup>7</sup> + 1 . x<sup>6</sup> + 1 . x<sup>5</sup> + 0 . x<sup>4</sup> + 0 . x<sup>3</sup> + 0 . x<sup>2</sup> + 1 . x<sup>1</sup> + 1 . x<sup>0</sup>**\n\nIn this n-degree polynomial, 'n' represents the number of registers and the presence of non-zero coefficients in terms except the n-th term and zeroth term represent the tap positions in the 8-bit LFSR based on Galois configuration. The tap positions define the XOR operation with the final register value. As per the above primitive polynomial, 8 registers are needed to construct the LFSR with 3 XOR operations.\n\nHere, \n`1 . x^6` represents the XOR operation between `lfsr_out[6]` XOR `lfsr_out[0]`\\\n `1 . x^5` represents the XOR operation between `lfsr_out[5]` XOR `lfsr_out[0]`\\\n `1 . x^1` represents the XOR operation between `lfsr_out[1]` XOR `lfsr_out[0]`\\\n\n The LFSR shifts the bits in the following way during every clock cycle. \n\nlfsr_out[7] = lfsr_out[0]\\\nlfsr_out[6] = lfsr_out[7]\\\nlfsr_out[5] = lfsr_out[6] XOR lfsr_out[0]\\\nlfsr_out[4] = lfsr_out[5] XOR lfsr_out[0]\\\nlfsr_out[3] = lfsr_out[4]\\\nlfsr_out[2] = lfsr_out[3]\\\nlfsr_out[1] = lfsr_out[2]\\\nlfsr_out[0] = lfsr_out[1] XOR lfsr_out[0]\n\nWhen the reset is HIGH with the LFSR seed as 8'b10011001 , the `lfsr_out` for a few clock cycles will be as follows:\n\nclk #1 -> lfsr_out = 8'b11111101\\\nclk #2 -> lfsr_out = 8'b11001111\\\nclk #3 -> lfsr_out = 8'b11010110\\\nclk #4 -> lfsr_out = 8'b01101011\\\nclk #5 -> lfsr_out = 8'b10000100\n\n#### Functional requirements:\n- The constructed 8-bit LFSR based on Galois configuration has to generate a maximal length sequence of (2<sup>8</sup> - 1) pseudo-random 8-bit sequences without supporting all-zero seed. In this case, the pseudo-random sequences fall in the range of values between 0000_0001 and 1111_1111\n\n- Following should be the interface of the RTL design of 8-bit LFSR module named `lfsr_8bit`\n\n#### Inputs:\n- `clock (1-bit)`: A single-bit input clock essential for the operation of the 8-bit LFSR, controlling data movement on the positive clock edge. Normally, the clock operates with a 50:50 duty cycle.\n- `reset (1-bit)`: A control signal that asynchronously resets the LFSR output to the initial seed when active LOW.\n- `lfsr_seed (8-bit, array index [7:0])`: An 8-bit initial seed that initializes the LFSR to trigger the pseudo-random sequence generation upon an asynchronous active LOW reset.\n\n#### Output:\n- `lfsr_out (8-bit, array index [7:0])`: Represents the output from the 8-bit LFSR. A new random value is output at each positive clock edge when the value of `reset` is HIGH.", "context": {}}, "output": {"response": "", "context": {"rtl/lfsr_8bit.sv": "module lfsr_8bit(input clock,reset,input [7:0] lfsr_seed, output reg [7:0] lfsr_out);\n\tlogic q1,q2,q3;\n\t//Primitive polynomial considered for 8-bit Linear Feedback Shift Register (LFSR) with Galois configuration is x^8+x^6+x^5+x+1 \n\t\n\t//Internal XORing based on primitive polynomial\n\tassign q1 = lfsr_out[6] ^ lfsr_out[0];\n\tassign q2 = lfsr_out[5] ^ lfsr_out[0];\n\tassign q3 = lfsr_out[1] ^ lfsr_out[0];\n\n\talways_ff @(posedge clock or negedge reset)\n\tbegin\n\t\tif (!reset)\n\t\t\tlfsr_out <= lfsr_seed;//If reset is at logic LOW, the initial seed will be loaded into LFSR's 8-bit output\n\t\telse\n\t\t\tlfsr_out <= {lfsr_out[0],lfsr_out[7],q1,q2,lfsr_out[4],lfsr_out[3],lfsr_out[2],q3};//Shift register based on the primitive polynomial\n\tend\nendmodule"}}, "harness": {"files": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\nRUN pip install cocotb-bus", "docker-compose.yml": "services:\n\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/lfsr_8bit.sv\nTOPLEVEL        = lfsr_8bit\nMODULE          = test_lfsr\nPYTHONPATH      = /src\nHASH            = d1acc6a3c4a0c29ba7e4695e76d1a864f1c84458", "src/test_lfsr.py": "import cocotb\nimport os\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer, Join\nimport random\n\n# ----------------------------------------\n# - Tests\n# ----------------------------------------\n\nasync def assert_seed(dut, value : int = 0):\n\n    # Assert seed value\n    dut.reset.value = 0\n    dut.lfsr_seed.value = value\n\n    # Synchronize with Falling Edge again\n    await FallingEdge(dut.clock)\n\n    for _ in range(2):\n        await RisingEdge(dut.clock)\n\n    dut.reset.value = 1\n\n    for i in range(256):\n        await RisingEdge(dut.clock)\n        if ((i == 0) or (i == 255)):\n            print(dut.lfsr_out)\n        if (i == 0):\n            first_value = dut.lfsr_out;\n        if (i == 0):\n            q1 = int(dut.lfsr_out[6]) ^ int(dut.lfsr_out[0])\n            q2 = int(dut.lfsr_out[5]) ^ int(dut.lfsr_out[0])\n            q3 = int(dut.lfsr_out[1]) ^ int(dut.lfsr_out[0])\n            lfsr_out =  (int(dut.lfsr_out[0]) << 7) | (int(dut.lfsr_out[7]) << 6) | (q1 << 5) | (q2 << 4) | (int(dut.lfsr_out[4]) << 3) | (int(dut.lfsr_out[3]) << 2) | (int(dut.lfsr_out[2]) << 1) | q3\n            print(\"lfsr_out \",lfsr_out)\n        if (i == 1):\n            second_value = int(dut.lfsr_out.value);\n            print(\"second_value \",second_value)\n        if (i == 255):\n            last_value = dut.lfsr_out;\n    if (first_value == last_value):\n        print(\"Max.length sequence\");\n    if (second_value == lfsr_out):\n        print(\"PRBS next sequence has been checked\")\n    assert second_value == lfsr_out, f\"The computed and DUT 8-bit LFSR sequences are not matching\"\n    assert first_value == last_value, f\"8-bit LFSR doesn't support maximal length sequence\"\n  \n\n@cocotb.test()\nasync def test_non_zero_1(dut):\n\n    # Start clock thread\n    cocotb.start_soon(Clock(dut.clock, 10, units='ns').start())\n\n    # Assert seed and wait\n    seed = int((1.0 - random.random()) * 2 ** 8);\n    print(\"seed_1 \",seed)\n    await assert_seed(dut, seed)\n\n@cocotb.test()\nasync def test_non_zero_2(dut):\n\n    # Start clock thread\n    cocotb.start_soon(Clock(dut.clock, 10, units='ns').start())\n\n  # Assert seed and wait\n    seed = int((1.0 - random.random()) * 2 ** 8)\n    print(\"seed_2 \",seed)\n    await assert_seed(dut, seed)\n    \n@cocotb.test()\nasync def test_non_zero_3(dut):\n\n    # Start clock thread\n    cocotb.start_soon(Clock(dut.clock, 10, units='ns').start())\n\n  # Assert seed and wait\n    seed = int((1.0 - random.random()) * 2 ** 8)\n    print(\"seed_3 \",seed)\n    await assert_seed(dut, seed)\n\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
